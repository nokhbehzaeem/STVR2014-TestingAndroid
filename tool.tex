\Subsection{Implementation}

The \tool{} tool embodies our approach.  \tool{} currently supports
testing of the following features\footnote{Zooming in and out
  functionality is currently unavailable in JUnit and Robotium
  frameworks, hence we did not include them in our tool.}: rotation,
killing and restarting, pausing and resuming, and Back button.
{}
There are four key steps in using \tool.
\\
%\begin{enumerate}
\indent
{\bf Step 1:} \tool{} receives a (manually or automatically generated)
model of the application's GUI as an XML file. \tool{} automatically
adds golden edges for the currently supported set of features.
%(rotation, killing and restarting, pausing and resuming, and Back button)
Then, \tool{} generates a graphical representation of the GUI
model using the dot program\footnote{http://www.graphviz.org} so that
the user can visually validate the model. Figure~\ref{fig:dotGraph} is
a sample graphical representation that \tool{} generated.
\\
\indent
{\bf Step 2:}
Once the model is validated, \tool{} traverses the model using traversal algorithms to generate test suites. \tool{} provides the following options for traversing the model: (1) our algorithm described in Section~\ref{sec:traversalAlgo} and (2) a basic Depth First Search algorithm (DFS) that covers all edges to serve as a baseline for comparison. On top of our traversal algorithm, each of the optimizations can be turned on or off independently. By traversing the model, \tool{} generates a suite of JUnit\footnote{http://junit.org} tests. The tests use a combination of Robotium\footnote{https://code.google.com/p/robotium} and JUnit to interact with Android apps.
\\
\indent
{\bf Step 3:}
In the generated test suite, \tool{} automatically inserts (1) instrumentation to record views of states, and (2) oracles after exercising each golden edge.
Recording views of states can be done through various user-interfaces provided by a mobile platform. We experimented with two interfaces from the Android platform: Hierarchy Viewer\footnote{http://developer.android.com/tools/help/hierarchy-viewer.html} and taking graphical snapshots.
\\
\indent
Hierarchy Viewer is a tool for debugging user-interfaces of apps that displays the hierarchy and properties of items on the screen.
%of the mobile device or emulator, their hierarchy, and their properties.
A programmatic interface is not available for Hierarchy Viewer to be used by tests, so we implemented one using Java reflection. The hierarchy and properties of items on the screen, provided by the state view, are then compared by oracles.
%This implementation included iterating over all items on the screen and fetching the value of their public fields through calling all of their public get methods. Then we used these values to compare two states of the app and assert oracles. However, we did not proceed with this method of obtaining details of the state of an app, because it has multiple drawbacks. Firstly, it is prone to false positive, since there are many public variables that are irrelevant to what is displayed on the screen. For example, the  \emph{getDrawingTime} method of an item shows how long it took to draw on the screen, which varies from time to time and falsely alarms difference between two states that are indeed the same. Secondly, it is relatively slow, since there might be many nested items on the screen each having various public variables.
\\
\indent
Graphical snapshots are taken from inside JUnit tests and are then compared using image processing. In the current implementation of \tool{}, snapshots of the states are automatically recorded and the comparison is based on a basic image differencing algorithm that uses the Red-Green-Blue coloring system to compare images pixel by pixel and allows for an adjustable threshold of difference.
%Listing~\ref{lst:sampleTest} shows the simplified version of a sample JUnit test that \tool{} generated for Kitchen Timer. The \emph{imagesEqual} method contains the basic image comparison algorithm.
Since the states are rendered on the same device and the same screen, it is conceivable that basic image comparison might be good enough. Indeed, taking graphical snapshots proved to be easier to use than Hierarchy Viewer for the currently implemented set of features, gave less false positives, and was faster.
\\
%\lstinputlisting[caption=Example Test Generated by \tool.,label=lst:sampleTest]{listings/sampleTest.java}
\indent
%Of course, one can use any other tool to record the state of the app, as long as the recording can be programmatically performed by test sequences and a method is provided for comparing states. Such different tools might be more appropriate for implementing an extended sets of features, e.g., zooming and scrolling.
\\
\indent
{\bf Step 4:}
Now the test suite is complete and can be run to test the app running on an Android device or emulator.
Each test case traverses and checks multiple golden edges. After executing each test, a log is provided which contains the result of checking each golden edge as Pass or Fail. In addition, \tool{} takes snapshots of the app and provides them along with the expected snapshot for each failure. These snapshots facilitate identifying false positives, evaluating the severity of bugs, and debugging.
%\end{enumerate}
